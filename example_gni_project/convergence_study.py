"""
Functions to analyze the convergence of a numerical scheme.
"""

import numpy as np
import matplotlib.pyplot as plt

from example_gni_project.time_stepping import simulate

__all__ = ['convergence_study', 'plot_errors']


def convergence_study(ivp, scheme, hs, duration, function=lambda x: x):
    """study the convergence of
    the given function of
    the discrete trajectory generated by the given scheme
    applied to the given initial value problem

    Parameters
    ----------
    ivp: IVP
        initial value problem
    scheme: function
        function defining the integration scheme
    hs: list of floats
        time step sizes
        The smallest time step is used to compute the reference.
    duration: float
        duration of simulation
        The duration needs to be divisible by all time step sizes in hs.
    function: function
        function of the state
        By default, the identity function will yield the global truncation error.


    Returns
    -------
    hs: list of floats
        time steps (excluding the reference)
    errors: list of floats
        corresponding to every time step in hs:
        norm of the deviation of the function value
        for the final state of the simulation
        from the corresponding value for the final state
        of the reference simulation
    p: float
        mean of the slopes of all segments
        in the log-log plot of error over time step
    """
    assert all([(duration / h) % 1 == 0 for h in hs])
    hs = sorted(hs)

    simulations = [simulate(ivp, scheme, h, duration) for h in hs]

    reference = simulations[0]
    hs = hs[1:]
    errors = [
        np.linalg.norm(
            function(simulation.trajectory[-1]) - function(reference.trajectory[-1])
        )
        for simulation in simulations[1:]
    ]

    log_hs = np.log(hs)
    log_errors = np.log(errors)
    ps = []  # array of slopes in the log-log plot
    for i in range(1, len(log_hs)):
        p = (log_errors[i] - log_errors[i - 1]) / (log_hs[i] - log_hs[i - 1])
        ps.append(p)

    p = np.mean(ps)

    return hs, errors, ps, p


def plot_errors(hs, errors, filename=None):
    """create log-log plot of errors over timesteps
    used to empirically analyze the convergence of a numerical scheme
    """
    fig, ax = plt.subplots()
    ax.set_xscale("log")
    ax.set_yscale("log")
    ax.set_xlabel("h")
    ax.set_ylabel("error norm")
    ax.plot(hs, errors, "-o")
    if filename:
        fig.savefig(filename)
